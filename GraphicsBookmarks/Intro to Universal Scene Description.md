# Introduction to USD

---

![](https://graphics.pixar.com/usd/docs/attachments/340328893/553309696.jpg)

-   [What is USD?](https://graphics.pixar.com/usd/docs/index.html#IntroductiontoUSD-WhatisUSD?)
-   [Why use USD?](https://graphics.pixar.com/usd/docs/index.html#IntroductiontoUSD-WhyuseUSD?)
-   [What can USD do?](https://graphics.pixar.com/usd/docs/index.html#IntroductiontoUSD-WhatcanUSDdo?)
-   [What can't USD do?](https://graphics.pixar.com/usd/docs/index.html#IntroductiontoUSD-Whatcan'tUSDdo?)
-   [Heritage of USD at Pixar](https://graphics.pixar.com/usd/docs/index.html#IntroductiontoUSD-HeritageofUSDatPixar)
-   [Further USD resources](https://graphics.pixar.com/usd/docs/index.html#IntroductiontoUSD-FurtherUSDresources)

# What is USD?

Pipelines capable of producing computer graphics films and games typically generate, store, and transmit great quantities of 3D data, which we call "scene description".  Each of many cooperating applications in the pipeline  (modeling, shading, animation, lighting, fx, rendering) typically has its own special form of scene description tailored to the specific needs and workflows of the application, and neither readable nor editable by any other application.  **Universal Scene Description (USD) is the first publicly available software that addresses the need to robustly and scalably interchange and augment arbitrary 3D scenes that may be _composed_ from many elemental assets.**   
  
USD provides for interchange of elemental assets (e.g. models) or animations.  But unlike other interchange packages, USD also enables assembly and organization of any number of assets into virtual sets, scenes, and shots, transmit them from application to application, and non-destructively edit them (as _overrides_), with a single, consistent API, in a single scenegraph.  USD provides a [rich toolset](https://graphics.pixar.com/usd/docs/USD-Toolset.html) for reading, writing, editing, and rapidly previewing 3D geometry and shading.  In addition, because USD's core scenegraph and "[composition engine](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Composition)" are agnostic of 3D, USD can be extended in a maintainable way to encode and compose data in other domains.

Concretely, USD is an [OpenSource project](https://github.com/PixarAnimationStudios/USD) released under a [modified Apache license](https://github.com/PixarAnimationStudios/USD/blob/master/LICENSE.txt).

# Why use USD?

USD is the core of Pixar's 3D graphics pipeline, used in every 3D authoring and rendering application, including Pixar's proprietary _Presto_ animation system.  Pixar is deeply committed to evolving and improving USD to address the following ongoing production concerns:

-   **Provide a rich, common language for defining, packaging, assembling, and editing 3D data, facilitating the use of multiple digital content creation applications.** Like many other interchange packages, USD provides a low-level data model that stipulates, at a "file format level", how data is encoded and organized, plus a (extensible) set of high-level schemas that provide meaningful API's and organization for concepts like [a mesh](https://graphics.pixar.com/usd/docs/api/class_usd_geom_mesh.html#details) or [a transform](https://graphics.pixar.com/usd/docs/api/class_usd_geom_xformable.html#details).  With such a foundation one can create geometry and shading caches.  But USD goes further to provide a recombinant set of ["composition arcs"](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-CompositionArcs) that can be used to package, aggregate, vary, and override primitive elements and assets, with a high-performance runtime evaluation engine, embodied in a compact scenegraph known as a [Stage](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Stage), for resolving the resulting "[composed scene description](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Composition)" and extracting (and authoring) data from it.  
    
-   **Allow multiple artists to collaborate on the same assets and scenes.** USD's most basic composition arc, [the subLayers operator](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-SubLayers), facilitates multiple artists in different departments, or within the same department, to simultaneously work on the same asset or scene, by allowing each artist to work in their own file (called a [_layer_](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Layer)), all of which will be combined and resolved in a "strength ordering" clearly specified in the USD files themselves.  This ability is not a magic bullet that can automatically adjust shading data in a stronger layer when the modeling artist changes the topology of geometry defined in a weaker layer, but it allows each artist to work independently without erasing or editing any other artist's work, and helps to provide a clear audit trail of changes that aids in addressing problems like the changing-topology problem.
-   **Maximize artistic iteration by minimizing latency.** As in many media, one of the most important ingredients to achieving high-quality digital art is the ability to iterate quickly and often on a design, an asset, an animation.  One of the most prominent impediments to iteration in 3D art is the speed with which an artist can get "good enough" visual feedback on the results of their edits, and the speed with which they can migrate new data between multiple applications, or restore a session that has crashed.  Speed is a primary, ongoing goal of the USD project at Pixar; we continue to explore algorithmic improvements, better ways to leverage modern multi-core systems and GPU's, and compression techniques to minimize latency in networked file-access.

If your needs are similar to or are a subset of the above, then USD may be an attractive choice. 

# What can USD do?

### USD can represent:

USD organizes data into hierarchical namespaces of [Prims](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Prim) (short for "primitive").  In addition to child prims, each prim can contain _Attributes_ and _Relationships_, collectively known as _Properties_. [Attributes](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Attribute) have [typed values](https://graphics.pixar.com/usd/docs/api/_usd__page__datatypes.html) that can vary over time; [Relationships](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Relationship) are multi-target "pointers" to other objects in a hierarchy, and USD takes care of remapping the targets automatically when referencing causes namespaces to change.  Both prims and properties can also have (non-time-varying) metadata.  Prims and their contents are organized into a file abstraction known as a [Layer](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Layer).

Built on top of this low-level, generic scene description, USD provides a set of schemas that establish a standard encoding and client API for common 3D CG concepts like:

-   **Geometry.** The [UsdGeom schemas](https://graphics.pixar.com/usd/docs/api/usd_geom_page_front.html) define ([OpenSubdiv](http://graphics.pixar.com/opensubdiv/docs/intro.html)-compliant) meshes, transforms, curves, points, nurbs patches, and several intrinsic solids.  It also defines: the concept of arbitrary [primvars](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Primvar) as attributes that can interpolate across a geometric surface; geometric extents and aggregate, computed bounding boxes; [pruning visibility](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Visibility); and an attribute called  [_purpose_](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Purpose) that expresses a (non-animatable) conditional visibility useful for deploying level-of-detail proxies and guides.
-   **Shading.** The UsdShade schemas define primitive shader nodes that can be connected into networks and packaged into materials, on which one can create a public interface of attributes that will drive parameters in the contained shader networks.  Although the UsdShade schemas are used in the USD plugins for transmitting renderman shading from Maya to Katana, please be aware that these schemas are in flux until the 1.0 USD release.
-   ****Model** and **Asset**** .  USD's composition operators allow you to construct arbitrarily large, complex scenes.  As an aid to processing, analyzing, and decomposing such scenes, USD formalizes the concepts of  [_model_](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Model) and  _[asset](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Asset)._ The "model" prim classification allows scenegraphs to be partitioned into logical, manageable chunks for traversal, working-set management, and data coalescing/caching.  The concept of "asset" shows up in USD at two levels: as a core datatype for referring unambiguously to an external file, which identifies which data needs to participate in [asset/path resolution](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-AssetResolution); and in the [AssetInfo](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-AssetInfo) schema for depositing a record of what assets have been referenced into a scene, which survives even if the scene is [flattened](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Flatten).  

### USD can compose and override:

The following is a very compact description of USD's composition semantics, with pinpoint links to more detailed descriptions.  You can also read a [longer, more graphic and leisurely description](http://openusd.org/overview.html). 

You can "stack" USD layers together using the [**_subLayers_** composition arc](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-SubLayers), and the composition engine will resolve the data contained in such ordered (nestable) "[LayerStacks](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-LayerStack)" similarly to how layers in Photoshop are composed.  Any prim in a layer can also contain one or more  [_**references**_ composition arcs](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-References) that target a prim in another (or the same!) layer, and composes the tree rooted at the target prim into the referencing prim - this is the primary way to assemble elemental assets into aggregates and complete scenes.  The [**_payload_** arc](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Payload) provides a "deferred reference" that can be selectively "loaded" (or unloaded) from a [Stage](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Stage) _after_ the stage was initially opened; judicious use of payloads allows you to structure scenes so that clients can easily manage "working sets", keeping in memory just the parts of the scene they need for the task at hand. _**[VariantSets](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-VariantSet)**_ allow an asset _creator_ to bundle different variations of an asset all into the a single package with a "variant selector" that downstream asset _consumers_ can switch, non-destructively, in stronger layers to change the variation they desire; any prim can define multiple VariantSets, which can vary along dependent or independent axes.  Finally,  _**[inherits](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Inherits)**_ and  _**[specializes](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Specializes)**_ composition arcs both establish a persistent (across further, upstream composition arcs) relationship between a "base" prim and a "derived" prim, such that the derived prim receives all of the overrides applied to the base prim anywhere in the composition; the technical difference between _inherits_ and _specializes_ lies in the particulars of when derived's opinions "win out" over base's opinions, but practically the difference is: you can use _inherits_ to easily "mass edit" all instances of a particular class of prim or asset, and you can use _specializes_ to create a "derived" that is always a "specialized" refinement of "base" in all views of your scene. 

The most powerful and unifying aspect of USD's composition semantics is that all of the above operators can be applied to any prim, in any combination, and the composition engine will [resolve the resulting graph in a predictable way](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-LIVRPSStrengthOrdering).  The other desirable property that falls out of this uniform treatment of composition arcs is that stronger layers in a composition can override the scene description in weaker layers _uniformly_, regardless of whether the weaker layers were subLayered, referenced, inherited, etc.  A stronger layer can override the following with respect to weaker layers:

-   **Add new prims** including entire subtrees rooted at the added prim
-   **[Deactivate](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Active/Inactive) prims**, which is USD's method for non-destructive (and reversible) prim/subtree deletion
-   **Reorder prims**, since in some contexts, the namespace-ordering can be meaningful
-   **Add or remove [Variants](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Variant)** to an existing VariantSet
-   **Add or remove entire VariantSets**, or targets to inherit or specialize
-   **Override the value of schema and user-level metadata** on a prim or property
-   **Add new properties** to a prim
-   **Reorder properties** on a prim.  If not explicitly ordered, properties are enumerated in Dictionary order
-   **Override the value of any attribute** (an override value blocks all weaker timeSamples)
-   **[Block the value](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-AttributeBlock) of an attribute**, so that it will appear to have no authored value
-   **Add, remove, and reorder targets on a relationship**

Finally, USD provides a handful of scenegraph-level features that can greatly expand the types and scale of datasets encodable in USD.  The two most prominent are [native prim Instancing](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-Instancing) for very compactly encoding (and processing) large numbers of instances/copies of a referenced asset or prim, applicable when the copies do not need to be deeply edited; and [Value Clips](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-ValueClips), which allow timeSamples for a set of prims to be scattered across many files, and (re-)sequenced and retimed non-destructively. 

### USD/Hydra can image:

[Hydra](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-HydraRenderer) is the imaging framework that ships as part of the USD distribution.  It connects multiple front-ends (that consume scene data) and multiple backends (that send the scene data to renderers).  Its first and primary "back end" is a modern OpenGL renderer, which is highly scalable, multi-pass and uses [OpenSubdiv](http://opensubdiv.org/) for mesh rendering.  The distribution also ships with a simple [Embree](https://embree.github.io/)-based path tracer to serve as an example for creating more backends.

The USD front-end to Hydra is used in _usdview_ and the third-party plugins included with the USD distribution, and is meant to provide a "ground truth" geometry rendering of any scene composed of prims conforming to the [UsdGeom schemas](https://graphics.pixar.com/usd/docs/api/usd_geom_page_front.html).  It also provides fast preview and animation streaming for USD scenes.

### USD can be extended/customized:

Even though USD will primarily be used as an embedded sub-system, the breadth of the problem-space it covers demands that it be extensible along a number of axes.  USD comes with its own [plugin discovery mechanism](https://graphics.pixar.com/usd/docs/api/plug_page_front.html), and the following plugin-points:

-   **Asset Resolution**. In a highly-referenced scene, it can be advantageous to have a degree of separation between the asset paths recorded in the USD files and the "resolved file path" from which the asset will ultimately be loaded.  The [ArResolver](https://graphics.pixar.com/usd/docs/api/class_ar_resolver.html) interface can be customized per USD installation, allowing, for example, site-specific naming conventions to be resolved, and for dynamic versioning control to be applied.  USD ships with a default resolver implementation that allows for simple "searchpath" style asset resolution.
-   **File Formats**. A USD Layer can be taught to be populated with translated data from any kind of compatible file format, by implementing an [SdfFileFormat](https://graphics.pixar.com/usd/docs/api/class_sdf_file_format.html) plugin for the format.  USD's own native ascii and binary formats are implemented this way, as is the included support for reading Alembic files via the [Alembic USD Plugin](https://graphics.pixar.com/usd/docs/Alembic-USD-Plugin.html).
-   **Schemas**. USD includes [a tool for generating new schemas](https://graphics.pixar.com/usd/docs/Generating-New-Schema-Classes.html) (C++ classes, python bindings, and all required boilerplate) from a simple usd ascii description of the schema.  This can be used to add new USD prim schema types and API's to your pipeline or package, with which you will be able to interact in your application-level plugins just as if they were native USD schemas.  For typed schemas that are conceptually imageable, you can also teach Hydra how to image them. 

# What can't USD do?

### No GUIDS

USD uses a textual, hierarchical namespace to identify its data, which means it is "namespace paths" by which overrides bind to their defining prims/properties.  In consequence, when the internal namespace of a referenced asset changes, _higher-level overrides previously recorded in referencing assets will fall off_.  One solution to this problem is to identify data by a "globally unique identifer" (GUID), and then associate overrides with the same GUID as the defining prim.  While solving the namespace-editing problem, GUIDs introduce other problems into a pipeline, and potentially limitations on flexibility of composition.  In past iterations of USD, Pixar used a form of GUID at the model/asset granularity, and after carefully weighing the pros and cons, we have decided that for us, the cost of occasional "namespace fix-up" operations run over a collection of assets is worth paying for the ease of asset construction and aggregation, and readable ascii asset representations that we get from namespace-paths as identifiers.

### Not an execution or rigging system

USD provides a lightweight, optimized scenegraph to facilitate authoring and efficient extraction of composed scene description.  However, it provides no other behaviors than composition of a namespace hierarchy and property [value resolution](https://graphics.pixar.com/usd/docs/USD-Glossary.html#USDGlossary-ValueResolution), and in the tradeoff space between low-memory footprint, higher-latency data access and high-memory footprint, low-latency access to data, USD's scenegraph leans more towards the former, whereas a high-performance execution engine requires the latter.  

Further, the more rigging behaviors and execution semantics we would add to USD, the more difficult it would become to interchange the data successfully between DCC's, since there is not, currently, broad agreement between vendors of what these behaviors should be.

USD and its schema generation tools should be suitable for encoding rigging for round-tripping rigging data in a particular application or custom pipeline, and USD does provide facilities that a client could use to build more extensive in-memory caches on top of a UsdStage to provide lower-latency access to data encoded in USD. But for now, these do not play a significant role in what we feel is the primary directive of USD: scalable interchange of geometric and shading data between DCC's in a 3D content creation pipeline.

# Heritage of USD at Pixar

USD is roughly the fourth generation of "composed scene description" developed at Pixar.  After muscling through [Toy Story](http://www.pixar.com/features_films/TOY-STORY), in which each shot was described by a single, linear program file, the Pixar R&D team began adding and evolving concepts for referencing, layering, editing, and variation in the context of its proprietary animation system, M_arionette_ (known internally as Menv), beginning with [A Bug's Life](http://www.pixar.com/features_films/A-BUG%27S-LIFE), and continuing over the course of the next ten feature films.

By 2004 it was clear that, although Marionette had grown quite powerful, its organically evolved provenance was becoming a hindrance to continued stable development and our ability to leverage important tools like multi-core systems.  The studio committed to the design and development of a ground-up, second-generation animation system now known as _Presto_, which was first used on [Brave](http://www.pixar.com/features_films/BRAVE) and all features since.  One of the problems with Marionette that Presto set out to address was that its various features for composing and overriding 3D scene description could not always be used together effectively, because they were spread across three different formats and "composition engines".  Presto delivered a second generation of scene description that was _unified_, enabling referencing, overriding, variation, and other operations at all granularities from a single mesh, to an entire model, to an environment or shot, encoded in a single ascii format and evaluated with a single composition engine.

However, at the same time, Pixar, along with much of the film and effects industry, found it advantageous to transition from a pipeline in which animation and rigging were kept live up until rendering, to one in which animation and rigs were baked out into efficient "pose caches" containing animated posed points and transforms, so that lighting, effects, and rendering could reduce the latency (and memory footprint) with which they can access the data.  Consequently, in 2008-2009, the pipeline development team began building _TidScene_, a geometry schema backed by a binary database (Berkeley DB), with a lightweight scenegraph as the mechanism for authoring and reading time-sampled data.  Key elements of TidScene included a (for the time) high performance OpenGL rendering plugin that enabled direct-from-TidScene preview rendering in all pipeline applications, and the development of a native referencing feature that was used (possibly abused) to achieve layering, scenegraph "isolation" (i.e. loading only a portion of the scene), asset referencing, and some support for variation.

The speed, scalability, and universal pipeline access of TidScene pose-caches were a success, but also put Pixar back into a place where we had multiple, competing systems for creating composed scene description, with different semantics, API's, and places in the pipeline where they could be used.  The mandate for the USD project, initiated in 2012, was to marry the (recently redesigned and improved) composition engine and low-level data model from Presto with the lazy-access, time-sampled data model and lightweight scenegraph from TidScene.  USD delivers an all-new scenegraph that sits on top of the very same composition engine that Presto uses, and has introduced parallel computation into all levels of the scene description and composition core.

A key component of the USD project was the development of an ultra-modern, scalable OpenGL rendering architecture, dubbed _Hydra_.  Hydra ships as part of the USD project because it adds tremendous value to USD adoption in a pipeline and is used in all our plugins, and it also provides a benchmark and reference for how to leverage USD's multithreading for fast scene loading and imaging, as well as updating efficiently in response to dynamic edits to a live UsdStage.  However, Hydra is a product in its own right, and already has other direct front-end couplings other than USD (including Presto and our Maya and Katana plugins), and is growing beyond its original OpenGL-inspired architecture to service other back-end clients, such as path-tracers.

# Further USD resources

-   [USD FAQ](https://graphics.pixar.com/usd/docs/USD-Frequently-Asked-Questions.html) to help you along in the process
-   [Developer API Documentation](https://graphics.pixar.com/usd/docs/api/index.html) from the source code
-   [The USD Toolset](https://graphics.pixar.com/usd/docs/USD-Toolset.html) which describes the main command-line tools for working with USD
-   [USD 3rd Party Plugins](https://graphics.pixar.com/usd/docs/USD-3rd-Party-Plugins.html) instructions on how to use our open-source plugins for the various DCC's
-   [Tutorials](https://graphics.pixar.com/usd/docs/USD-Tutorials.html) with links to advanced topic articles
-   [Glossary of USD terms and concepts](https://graphics.pixar.com/usd/docs/USD-Glossary.html)
-   [Contributing to USD](https://graphics.pixar.com/usd/docs/Contributing-to-USD.html) to the project
-   [Getting Help with USD](https://graphics.pixar.com/usd/docs/Getting-Help-with-USD.html)
-   [Press](https://graphics.pixar.com/usd/docs/Press.html) releases
-   [USD White Papers](https://graphics.pixar.com/usd/docs/USD-White-Papers.html) for deeper analysis and understanding of selected USD features.