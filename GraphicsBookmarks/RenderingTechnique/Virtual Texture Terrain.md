# Virtual Texture Terrain

[Programming](https://www.gamedev.net/tutorials/programming)

[Graphics and GPU Programming](https://www.gamedev.net/tutorials/programming/graphics)

Published July 14, 2013 by Josh Klint, posted by [Josh Klint](https://www.gamedev.net/josh-klint)

_Do you see issues with this article? [Let us know](mailto:support@gamedev.net)_.

The Leadwerks 2 terrain system was expansive and very fast, which allowed rendering of huge landscapes. However, it had some limitations. Texture splatting was done in real-time in the pixel shader. Because of the limitations of hardware texture units, only four texture units per terrain were supported. This limited the ability of the artist to make terrains with a lot of variation. The landscapes were beautiful, but somewhat monotonous. With the Leadwerks 3 terrain system, I wanted to retain the advantages of terrain in Leadwerks 2, but overcome some of the limitations. There were three different approaches we could use to increase the number of terrain textures.

-   Increase the number of textures used in the shader.
-   Allow up to four textures per terrain chunk. These would be determined either programmatically based on which texture layers were in use on that section, or defined by the artist.
-   Implement a virtual texture system like id Software used in the game _Rage_.

Since Leadwerks 3 runs on mobile devices as well as PC and Mac, we couldn't use any more texture units than we had before, so the first option was out. The second option is how Crysis handles terrain layers. If you start painting layers in the Crysis editor, you will see when "old" layers disappear as you paint new ones on. This struck me as a bad approach because it would either involve the engine "guessing" which layers should have priority, or involve a tedious process of user-defined layers for each terrain chunk. A virtual texturing approach seemed liked the ideal choice. Basically, this would render near sections of the terrain at a high resolution, and far sections of the terrain at low resolutions, with a shader that chose between them. If done correctly, the result should be the same as using one impossibly huge texture (like 1,048,576 x 1,048,576 pixels) at a much lower memory cost. However, there were some serious challenges to be overcome, so much so that I added a disclaimer in our [Kickstarter](http://www.kickstarter.com/projects/1937035674/leadwerks-build-linux-games-on-linux) campaign basically saying "this might not work"..

## Previous Work

id Software pioneered this technique with the game _Rage_ (a previous implementation was in _Quake Wars_). However, id's "megatexture" technique had some serious downsides. First, the data size requirements of storing completely unique textures for the entire world were prohibitive. _Rage_ takes about 20 gigs of hard drive space, with terrains much smaller than the size I wanted to be able to use. The second problem with id's approach is that both games using this technique have some pretty blurry textures in the foreground, although the unique texturing looks beautiful from a distance. [![gf8800_trailer_1.jpg](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-26333700-1373311408.jpg)](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-26333700-1373311408.jpg) I decided to overcome the data size problem by dynamically generating the megatexture data, rather than storing it on the hard drive. This involves a pre-rendering step where layers are rendered to the terrain virtual textures, and then the virtual textures are applied to the terrain. Since id's art pipeline was basically just conventional texture splatting combined with "stamps" (decals), I didn't see any reason to permanently store that data. I did not have a simple solution to the blurry texture problem, so I just went ahead and started implementing my idea, with the understanding that the texture resolution issue could kill it. I had two prior examples to work from. One was a [blog](http://frictionalgames.blogspot.com/2010/11/tech-feature-terrain-textures.html) from a developer at Frictional Games (_Amnesia: The Dark Descent_ and _Penumbra_). The other was a [presentation](http://www.gdcvault.com/play/1277/HALO-WARS-The-Terrain-of) describing the technique's use in the game _Halo Wars_. In both of these games, a fixed camera distance could be relied on, which made the job of adjusting texture resolution much easier. Leadwerks, on the other hand, is a general-purpose game engine for making any kind of game. Would it be possible to write an implementation that would provide acceptable texture resolution for everything from flight sims to first-person shooters? I had no idea if it would work, but I went forward anyway.

## Implementation

Because both Frictional Games and id had split the terrain into "cells" and used a texture for each section, I tried that approach first. Our terrain already gets split up and rendered in identical chunks, but I needed smaller pieces for the near sections. I adjusted the algorithm to render the nearest chunks in smaller pieces. I then allocated a 2048x2048 texture for each inner section, and used a 1024x1024 texture for each outer section: [![terrain.jpg](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-73346200-1373311446.jpg)](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-73346200-1373311446.jpg) The memory requirements of this approach can be calculated as follows: 1024 * 1024 * 4 * 12 = 50331648 bytes 2048 * 2048 * 4 * 8 = 134217728 Total = 184549376 bytes = 176 megabytes 176 megs is a lot of texture data. In addition, the texture resolution wasn't even that good at near distances. You can see my attempt with this approach in the image below. The red area is beyond the virtual texture range, and only uses a single low-res baked texture. The draw distance was low, the memory consumption high, and the resolution was too low. [![grid.jpg](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-06942000-1373311501.jpg)](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-06942000-1373311501.jpg) This was a failure, and I thought maybe this technique was just impractical for anything but very controlled cases in certain games. I wasn't ready to give up yet without trying one last approach. Instead of allocating textures for a grid section, I tried creating a radiating series of textures extending away from the camera: [![terr2.jpg](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-89107700-1373311459.jpg)](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-89107700-1373311459.jpg) The resulting resolution wasn't great, but the memory consumption was a lot lower, and terrain texturing was now completely decoupled from the terrain geometry. I found by adjusting the distances at which the texture switches, I could get a pretty good resolution in the foreground. I was using only three texture stages, so I increased the number to six and found I could get a good resolution at all distances, using just six 1024x1024 textures. The memory consumption for this was just 24 megabytes, a very reasonable number. Since the texturing is independent from terrain geometry, the user can fine-tune the texture distances to accommodate flight sims, RPGs, or whatever kind of game they are making. [![goodterrain.jpg](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-62412000-1373311518.jpg)](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-62412000-1373311518.jpg) The last step was to add some padding around each virtual texture, so the virtual textures did not have to be completely redrawn each time the camera moves. I used a value of 0.25 the size of the texture range so the various virtual textures only get redrawn once in a while.

## Advantages of Virtual Textures

First, because the terrain shader only has to perform a few lookups each pixel with almost no math, the new terrain shader runs much faster than the old one. When the bottleneck for most games is the pixel fillrate, this will make Leadwerks 3 games faster. Second, this allows us to use any number of texture layers on a terrain, with virtually no difference in rendering speed. This gives artists the flexibility to paint anything they want on the terrain, without worrying about budgets and constraints. A third advantage is that this allows the addition of "stamps", which are decals rendered directly into the virtual texture. This allows you to add craters, clumps of rocks, and other details directly onto the terrain. The cost of rendering them in is negligible, and the resulting virtual texture runs at the exact same speed, no matter how much detail you pack into it. Below you can see a simple example. The smiley faces are baked into the virtual texture, not rendered on top of the terrain: [![Image1.jpg](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-41715700-1373403976.jpg)](https://uploads.gamedev.net/monthly_07_2013/ccs-177507-0-41715700-1373403976.jpg)

## Conclusion

The texture resolution problem I feared might make this approach impossible was solved by using a graduated series of six textures radiating out around the camera. I plan to implement some reasonable default settings, and it's only a minor hassle for the user to adjust the virtual texture draw distances beyond that. Rendering the virtual textures dynamically eliminates the high space requirements of id's megatexture technique, and also gets rid of the problems of paging texture data dynamically from the hard drive. At the same time, most of the flexibility of the megatexture technique is retained. Having the ability to paint terrain with any number of texture layers, plus the added stamping feature gives the artist a lot more flexibility than our old technique offered, and it even runs faster than the old terrain. This removes a major source of uncertainty from the development of Leadwerks 3.1 and turned out to be one of my favorite features in the new engine.